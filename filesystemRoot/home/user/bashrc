# ~/.bashrc

# If not running interactively, don't do anything
case $- in *i*) ;; *) return ;; esac

# Load Git prompt script for __git_ps1, if available (to show Git info in prompt)
if [ -f "/etc/bash_completion.d/git-prompt" ]; then
    . /etc/bash_completion.d/git-prompt
elif [ -f "/usr/share/git/completion/git-prompt.sh" ]; then
    . /usr/share/git/completion/git-prompt.sh
elif [ -f "$HOME/.git-prompt.sh" ]; then
    . "$HOME/.git-prompt.sh"
fi

# Define color escape sequences (wrapped in \[ \] for prompt safe length)
Color_Off="\[\033[0m\]"    # Text Reset
# Regular colors
Black="\[\033[0;30m\]";   Red="\[\033[0;31m\]";   Green="\[\033[0;32m\]"; Yellow="\[\033[0;33m\]"
Blue="\[\033[0;34m\]";    Purple="\[\033[0;35m\]"; Cyan="\[\033[0;36m\]";  White="\[\033[0;37m\]"
# Bright colors
IBlack="\[\033[0;90m\]";  IRed="\[\033[0;91m\]";   IGreen="\[\033[0;92m\]"; IYellow="\[\033[0;93m\]"
IBlue="\[\033[0;94m\]";   IPurple="\[\033[0;95m\]"; ICyan="\[\033[0;96m\]";  IWhite="\[\033[0;97m\]"

# Configure Git prompt options for status indicators
export GIT_PS1_SHOWDIRTYSTATE=1      # '*' for unstaged changes, '+' for staged changes
export GIT_PS1_SHOWUNTRACKEDFILES=1  # '%' for untracked files

# Compose the prompt (PS1) with proper escape wrapping
# Includes: terminal title, timestamp, user@host, current directory, and Git branch@commit*status
Title="\[\e]0;\u@\h: \w\007\]"  # Terminal title: user@host: cwd (non-printing)
PS1="${Title}${IBlack}\A${Color_Off} "                  # time in gray, then space
PS1+="${ICyan}\u@\h${Color_Off}:"                       # user@host in cyan, then colon
PS1+="${IYellow}\w${Color_Off}"                         # working directory in yellow
PS1+="${IGreen}\$(if git rev-parse --is-inside-work-tree &>/dev/null; then "  # if in a Git repo...
PS1+="branch=\$(git rev-parse --abbrev-ref HEAD 2>/dev/null); "             # get branch name
PS1+="commit=\$(git rev-parse --short HEAD 2>/dev/null); "                 # get short commit hash
PS1+="dirty=\"\"; "                                                       # reset dirty flag
PS1+="git diff --quiet 2>/dev/null || dirty=\"*\"; "                      # add '*' if unstaged changes
PS1+="git diff --cached --quiet 2>/dev/null || dirty=\"\${dirty}+\"; "    # add '+' if staged changes
PS1+="printf ' (%s@%s%s)' \"\$branch\" \"\$commit\" \"\$dirty\"; "        # print branch@commit*status
PS1+="fi)${Color_Off} \$ "                                               # end if, reset color, and add shell prompt symbol

# Custom 'cd' wrapper (preserve additional functionality if any)
cd() {
    builtin cd "$@" || return       # change directory
    # (Add any custom behavior here, e.g. auto-list contents or update environment)
}

# Custom 'nano' wrapper (preserve additional functionality if any)
nano() {
    /usr/bin/nano -l -B "$@"
    # -l (show line numbers), -B (make backup). Adjust or add options as needed for custom behavior.
}

# Preexec function to run right before each interactive command
preexec_invoke_exec() {
    [ -z "$COMP_LINE" ] || return            # skip if performing tab-completion
    if declare -F preexec >/dev/null; then   # if user defined a preexec() hook
        preexec "$BASH_COMMAND"              # call it with the command about to be executed
    fi
}
# Activate preexec hook via DEBUG trap
trap 'preexec_invoke_exec' DEBUG

# If a precmd() function is defined, use it to run commands before each prompt display
if declare -F precmd >/dev/null; then
    PROMPT_COMMAND="precmd"
fi

# Login shell utilities (run only on first login shell)
if shopt -q login_shell; then
    # Welcome message and basic system info
    echo -e "Welcome, \e[1m$USER\e[0m! Today is $(date)."
    if command -v neofetch &>/dev/null; then
        neofetch          # show system info with neofetch if available
    elif command -v screenfetch &>/dev/null; then
        screenfetch       # alternative system info display
    else
        # Fallback basic info
        echo "Hostname: $(hostname)"
        echo "OS: $(uname -srmo)"
        echo "Uptime: $(uptime -p)"
    fi
fi
