#!/bin/bash
# File_Rel_Path: 'filesystemRoot/home/user/bashrc'
# File_Type: '.sh'

##############################################################################
# 1) Only load if interactive
##############################################################################
case $- in
    *i*) ;;
    *) return ;;
esac

##############################################################################
# 2) Fastfetch or Neofetch
##############################################################################
if command -v fastfetch &>/dev/null; then
    fastfetch --logo none
elif command -v neofetch &>/dev/null; then
    neofetch --ascii_distro "none"
fi

##############################################################################
# 3) Basic Environment
##############################################################################
HOST_ALIAS=$(hostname)
TEXTC_DIRECTORY="$HOME/.alfe.sh/FaybianScripts/utils"
HISTCONTROL=ignoreboth
HISTSIZE=1000
HISTFILESIZE=2000
HISTTIMEFORMAT="%F %T "
export VIRTUAL_ENV_DISABLE_PROMPT=1

shopt -s histappend
shopt -s checkwinsize

if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

##############################################################################
# 4) Detect Terminal Color Support
##############################################################################
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes ;;
esac

if [ -n "$force_color_prompt" ]; then
    if command -v tput &>/dev/null && tput setaf 1 &>/dev/null; then
        color_prompt=yes
    else
        color_prompt=
    fi
fi

##############################################################################
# 5) Define Real ESC
##############################################################################
ESC="$(printf '\033')"  # actual escape character

##############################################################################
# 6) Git Prompt Info
##############################################################################
git_prompt_info() {
    git rev-parse --is-inside-work-tree &>/dev/null || return
    local branch color status_output timestamp hash

    branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    timestamp=$(git show -s --format=%cd --date=format-local:'%m/%d/%y %H:%M' HEAD 2>/dev/null)
    hash=$(git rev-parse --short HEAD 2>/dev/null)
    status_output=$(git status --porcelain 2>/dev/null)

    if [ -z "$status_output" ] && git status | grep -q "Your branch is up to date with"; then
        color="\[${ESC}[01;32m\]"  # Bold green
        echo -n "${color}($hash, $branch, clean, $timestamp)\[${ESC}[00m\]"
    else
        color="\[${ESC}[01;33m\]"  # Bold yellow
        local num_changes
        num_changes=$(echo "$status_output" | wc -l | tr -d ' ')
        echo -n "${color}($hash, $branch, ${num_changes} changes, $timestamp)\[${ESC}[00m\]"
    fi
}

##############################################################################
# 7) Primary Prompt (PS1)
##############################################################################
if [ "$color_prompt" = yes ]; then
    # Colorful PS1 using real ESC references
    PS1="\[${ESC}[90m\]\$(date '+%m/%d/%y %H:%M:%S')\[${ESC}[00m\] ${debian_chroot:+($debian_chroot)}\[${ESC}[01;32m\]\u@$HOST_ALIAS\$(git_prompt_info)\[${ESC}[00m\]\n:\[${ESC}[01;34m\]\w\[${ESC}[00m\]\$ "
else
    PS1="\$(date '+%m/%d/%y %H:%M:%S') ${debian_chroot:+($debian_chroot)}\u@$HOST_ALIAS\$(git_prompt_info)\n:\w\$ "
fi

unset color_prompt force_color_prompt

##############################################################################
# 8) If xterm-like, set window title
##############################################################################
case "$TERM" in
    xterm*|rxvt*)
        PS1="\[${ESC}]0;${debian_chroot:+($debian_chroot)}\u@$HOST_ALIAS: \w\a\]$PS1"
        ;;
esac

##############################################################################
# 9) dircolors, Aliases, and Bash Completion
##############################################################################
if [ -x /usr/bin/dircolors ]; then
    if [ -r ~/.dircolors ]; then
        eval "$(dircolors -b ~/.dircolors)"
    else
        eval "$(dircolors -b)"
    fi
    alias ls='ls --color=auto'
fi

[ -f ~/.bash_aliases ] && . ~/.bash_aliases

if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

##############################################################################
# 10) Enhanced cd with JSON logging
##############################################################################
cd() {
    local old_cwd="$PWD"
    builtin cd "$@" || return
    pwd
    ls

    local new_cwd="$PWD"
    local timestamp=$(date +%s%3N)
    local pid="$$"
    local user="$USER"

    local log_dir="$HOME/.alfe.sh/alsh/dir_history/$pid"
    mkdir -p "$log_dir"
    local log_file="$log_dir/${timestamp}.json"

    local escaped_old_cwd
    local escaped_new_cwd
    local escaped_cd_command
    escaped_old_cwd=$(printf '%s' "$old_cwd" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\n/\\n/g' -e 's/\r/\\r/g')
    escaped_new_cwd=$(printf '%s' "$new_cwd" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\n/\\n/g' -e 's/\r/\\r/g')
    local cd_command="cd $*"
    escaped_cd_command=$(printf '%s' "$cd_command" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\n/\\n/g' -e 's/\r/\\r/g')

cat <<EOF > "$log_file"
{
    "timestamp": "$timestamp",
    "pid": "$pid",
    "user": "$user",
    "old_cwd": "$escaped_old_cwd",
    "new_cwd": "$escaped_new_cwd",
    "cd_command": "$escaped_cd_command"
}
EOF
}

alias n='nano'

##############################################################################
# 11) Info on login
##############################################################################
echo "-------------"
"$TEXTC_DIRECTORY/textc.sh" --color darkred --text "Language Versions:"
echo "Node.js version: $(node -v)"
echo ""

d() {
    echo "-------------"
    "$TEXTC_DIRECTORY/textc.sh" --color darkred --text "Filesystem:"
    echo "Filesystem      Size  Used Avail Use% Mounted on"
    df -h | awk 'NR>1 && ($NF=="/" || $NF ~ /^\/mnt/)'
    echo ""

    echo "-------------"
    "$TEXTC_DIRECTORY/textc.sh" --color darkred --text "Screens:"
    screen -list
    echo ""
}
d

pd() {
    echo "-------------"
    "$TEXTC_DIRECTORY/textc.sh" --color darkred --text "Git Status:"
    git status
    echo ""
    git log -n 3 --pretty=format:'%H %ai %an <%ae> %s' --abbrev-commit
    echo ""
    git remote -v
    echo ""
    echo "-------------"
    "$TEXTC_DIRECTORY/textc.sh" --color darkred --text "Current Directory:"
    pwd
    echo "-------------"
}
pd

##############################################################################
# 12) Custom Git
##############################################################################
git() {
    if [ "$1" == "fpush" ] || [ "$1" == "fp" ] || [ "$1" == "f" ]; then
        shift
        ~/.fayra/Whimsical/git/faybian-git_reset/git_fpush.sh "$@"
    elif [ "$1" == "s" ] || [ "$1" == "status" ]; then
        shift
        sh -c "git status $*" | sed -e '/nothing to commit, working tree clean/ s/.*/'"${ESC}"'[32m&'"${ESC}"'[0m/'
    else
        command git "$@"
    fi
}
export -f git

alias gitf='git f'

history() {
    ~/.alfe.sh/alsh/history_reader.sh "$@"
}
export -f history

dir_history() {
    ~/.alfe.sh/alsh/dir_history.sh "$@"
}
export -f dir_history

##############################################################################
# 13) Navigation shortcuts
##############################################################################
back() {
    local last_dir
    last_dir=$(~/.alfe.sh/alsh/dir_history.sh -n 2 | tail -n 1 | awk '{for(i=4;i<=NF;++i)printf "%s ",$i; print ""}' | sed 's/[[:space:]]*$//')
    if [ -n "$last_dir" ] && [ -d "$last_dir" ]; then
        cd "$last_dir"
    else
        echo "No previous directory found."
    fi
}
alias cdp='back'
alias cdb='back'
alias b='back'

##############################################################################
# 14) Window Title
##############################################################################
update_window_title() {
    local home="${HOME%/}"
    local SHORT_PWD

    if [[ "$PWD" == "$home" ]]; then
        SHORT_PWD="~"
    elif [[ "$PWD" == "$home/"* ]]; then
        SHORT_PWD="~/${PWD#$home/}"
    else
        SHORT_PWD="$PWD"
    fi

    TITLE="$USER@$HOSTNAME:$SHORT_PWD\$"
    [ -n "$TITLE_OVERRIDE" ] && TITLE="$TITLE_OVERRIDE"
    echo -ne "${ESC}]0;${TITLE}\007"
}

set_title() {
    TITLE_OVERRIDE="$*"
    update_window_title
}

PROMPT_COMMAND="update_window_title"
update_window_title

##############################################################################
# 15) Log each command
##############################################################################
preexec_invoke_exec() {
    [ -n "$COMP_LINE" ] && return
    [[ "$BASH_COMMAND" == "$PROMPT_COMMAND" || "$BASH_COMMAND" == "preexec"* ]] && return

    echo -e "${ESC}[0;32m$(date '+%m/%d/%y %H:%M:%S')${ESC}[0m"
    local command="$BASH_COMMAND"
    if [[ "$command" == *$'\n'* ]]; then
        command=$(echo "$command" | tr '\n' ';')
    fi

    local timestamp=$(date +%s%3N)
    local pid="$$"
    local user="$USER"
    local cwd="$PWD"

    local log_dir="$HOME/.alfe.sh/alsh/history/$pid"
    mkdir -p "$log_dir"
    local log_file="$log_dir/${timestamp}.json"

    local escaped_command
    local escaped_cwd
    escaped_command=$(printf '%s' "$command" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\n/\\n/g' -e 's/\r/\\r/g')
    escaped_cwd=$(printf '%s' "$cwd"     | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\n/\\n/g' -e 's/\r/\\r/g')

cat <<EOF > "$log_file"
{
    "timestamp": "$timestamp",
    "pid": "$pid",
    "user": "$user",
    "cwd": "$escaped_cwd",
    "command": "$escaped_command"
}
EOF
}
trap 'preexec_invoke_exec' DEBUG

##############################################################################
# 16) Enhanced nano
##############################################################################
nano() {
    local new_files=()
    for arg in "$@"; do
        if [[ "$arg" == *.sh ]] && [ ! -f "$arg" ]; then
            echo "#!/bin/bash" > "$arg"
            new_files+=("$arg")
        fi
        if [[ "$arg" == ".gitignore" ]] && [ ! -f "$arg" ]; then
            cat ~/.alfe.sh/git/faybian-scripts-org/default.gitignore > "$arg"
        fi
    done

    command nano "$@"
    echo "Nano session closed at $(date '+%Y-%m-%d %H:%M:%S')" >> "$HOME/.nano_history.log"

    for f in "${new_files[@]}"; do
        chmod +x "$f"
    done

    for f in "$@"; do
        [ -f "$f" ] || continue
        sed -i -e '1{/^===== Start of file: /d}' -e '${/^===== End of file: /d}' "$f"
    done
}

alias bashup='~/.alfe.sh/git/faybian-scripts-org/utils/cp_git_to_bashrc.sh'
alias bup='~/.alfe.sh/git/faybian-scripts-org/utils/cp_git_to_bashrc.sh'
alias alsh='bash'

##############################################################################
# 17) Misc
##############################################################################
rs() {
    redshift -x && redshift -O "$1"
}
export -f rs

symlink() {
    if [ "$#" -ne 2 ]; then
        echo "Usage: symlink <target> <linkName>"
        return 1
    fi
    ln -s "$1" "$2"
}
export -f symlink

rmn() {
    if [ "$#" -eq 0 ]; then
        echo "Usage: rmn <filename>"
    else
        rm "$1" && nano "$1"
    fi
}
alias rnm='rmn'
alias nrm='rmn'
alias e='exit'

# End of file
